from __future__ import annotations

from typing import Any, Callable, Optional, Protocol

from easyshift_maas.core.contracts import (
    ConstraintOperator,
    ConstraintSeverity,
    ConstraintSpec,
    FieldDictionary,
    GuardrailAction,
    GuardrailRule,
    GuardrailSpec,
    IssueSeverity,
    MigrationDraft,
    MigrationRisk,
    ObjectiveDirection,
    ObjectiveSpec,
    ObjectiveTerm,
    OptimizationSpec,
    PredictionSpec,
    ScenarioTemplate,
    SceneMetadata,
)


class MigrationAssistantProtocol(Protocol):
    def generate(
        self,
        scene_metadata: SceneMetadata,
        field_dictionary: FieldDictionary,
        nl_requirements: list[str],
    ) -> MigrationDraft: ...


class HybridMigrationAssistant:
    """Rule-first assistant with optional LLM enrichment and confidence-aware fallback."""

    def __init__(
        self,
        llm_suggester: Optional[Callable[[dict[str, Any]], dict[str, Any]]] = None,
        llm_threshold: float = 0.78,
    ) -> None:
        self.llm_suggester = llm_suggester
        self.llm_threshold = llm_threshold

    def generate(
        self,
        scene_metadata: SceneMetadata,
        field_dictionary: FieldDictionary,
        nl_requirements: list[str],
    ) -> MigrationDraft:
        base_template = self._build_rule_template(scene_metadata, field_dictionary)
        confidence = self._estimate_confidence(base_template, nl_requirements)
        pending = ["Confirm objective term weights", "Confirm hard/soft constraint severities"]
        risks = self._base_risks(base_template)
        strategy = "rule_only"

        if self.llm_suggester and confidence >= self.llm_threshold:
            payload = {
                "scene_metadata": scene_metadata.model_dump(),
                "field_dictionary": field_dictionary.model_dump(),
                "nl_requirements": nl_requirements,
                "template": base_template.model_dump(mode="json"),
            }
            try:
                suggestions = self.llm_suggester(payload)
                base_template = self._merge_suggestions(base_template, suggestions)
                confidence = min(0.97, confidence + 0.08)
                strategy = "hybrid_llm_rule"
            except Exception as exc:  # noqa: BLE001
                risks.append(
                    MigrationRisk(
                        code="LLM_SUGGESTION_FAILED",
                        message=f"LLM suggestion unavailable, fallback to rules: {exc}",
                        severity=IssueSeverity.WARN,
                    )
                )
                strategy = "rule_fallback"

        if confidence < self.llm_threshold:
            strategy = "rule_only_low_confidence"
            pending.append("Low-confidence migration, manual review required")

        return MigrationDraft(
            template=base_template,
            confidence=confidence,
            pending_confirmations=pending,
            risks=risks,
            generation_strategy=strategy,
        )

    def _build_rule_template(
        self,
        scene_metadata: SceneMetadata,
        field_dictionary: FieldDictionary,
    ) -> ScenarioTemplate:
        objective_terms = self._infer_objective_terms(field_dictionary)
        if not objective_terms:
            fallback_field = field_dictionary.fields[0].field_name if field_dictionary.fields else "proxy_metric"
            objective_terms = [
                ObjectiveTerm(field_name=fallback_field, direction=ObjectiveDirection.MIN, weight=1.0)
            ]

        prediction_features = field_dictionary.field_names()[: min(8, len(field_dictionary.fields))]
        if not prediction_features and objective_terms:
            prediction_features = [objective_terms[0].field_name]

        constraints = self._infer_constraints(field_dictionary)
        guardrail = self._infer_guardrail(field_dictionary, objective_terms)

        template_id = f"{scene_metadata.scene_id}-template"
        return ScenarioTemplate(
            template_id=template_id,
            version="draft-1",
            scene_metadata=scene_metadata,
            field_dictionary=field_dictionary,
            objective=ObjectiveSpec(terms=objective_terms),
            constraints=constraints,
            prediction=PredictionSpec(
                feature_fields=prediction_features,
                horizon_steps=max(1, min(12, scene_metadata.execution_window_sec // scene_metadata.granularity_sec)),
                model_signature="rule-bootstrap:v1",
            ),
            optimization=OptimizationSpec(
                solver_name="projected-heuristic",
                max_iterations=60,
                tolerance=1e-6,
                time_budget_ms=300,
            ),
            guardrail=guardrail,
            notes="Generated by HybridMigrationAssistant with rule-first strategy.",
        )

    def _infer_objective_terms(self, field_dictionary: FieldDictionary) -> list[ObjectiveTerm]:
        terms: list[ObjectiveTerm] = []
        for field in field_dictionary.fields:
            label = f"{field.field_name} {field.semantic_label}".lower()
            if any(token in label for token in ["efficiency", "yield", "quality"]):
                terms.append(
                    ObjectiveTerm(
                        field_name=field.field_name,
                        direction=ObjectiveDirection.MAX,
                        weight=1.0,
                    )
                )
            elif any(token in label for token in ["cost", "energy", "consumption", "emission"]):
                terms.append(
                    ObjectiveTerm(
                        field_name=field.field_name,
                        direction=ObjectiveDirection.MIN,
                        weight=1.0,
                    )
                )
        return terms[:3]

    def _infer_constraints(self, field_dictionary: FieldDictionary) -> list[ConstraintSpec]:
        constraints: list[ConstraintSpec] = []
        for field in field_dictionary.fields:
            label = f"{field.field_name} {field.semantic_label}".lower()
            if "temperature" in label:
                constraints.append(
                    ConstraintSpec(
                        name=f"{field.field_name}_range",
                        field_name=field.field_name,
                        operator=ConstraintOperator.BETWEEN,
                        lower_bound=0.0,
                        upper_bound=1200.0,
                        severity=ConstraintSeverity.HARD,
                        priority=10,
                    )
                )
            elif "pressure" in label:
                constraints.append(
                    ConstraintSpec(
                        name=f"{field.field_name}_range",
                        field_name=field.field_name,
                        operator=ConstraintOperator.BETWEEN,
                        lower_bound=0.0,
                        upper_bound=500.0,
                        severity=ConstraintSeverity.HARD,
                        priority=20,
                    )
                )
            elif any(token in label for token in ["flow", "rate", "power"]):
                constraints.append(
                    ConstraintSpec(
                        name=f"{field.field_name}_nonnegative",
                        field_name=field.field_name,
                        operator=ConstraintOperator.GE,
                        lower_bound=0.0,
                        severity=ConstraintSeverity.HARD,
                        priority=30,
                    )
                )

        return constraints

    def _infer_guardrail(
        self,
        field_dictionary: FieldDictionary,
        objective_terms: list[ObjectiveTerm],
    ) -> GuardrailSpec:
        rules: list[GuardrailRule] = []
        covered: set[str] = set()
        for term in objective_terms:
            field = next((item for item in field_dictionary.fields if item.field_name == term.field_name), None)
            if field is None:
                continue
            label = f"{field.field_name} {field.semantic_label}".lower()
            if any(token in label for token in ["temperature", "pressure"]):
                rules.append(
                    GuardrailRule(
                        field_name=term.field_name,
                        min_value=0.0,
                        max_value=1200.0 if "temperature" in label else 500.0,
                        max_delta=80.0,
                        action=GuardrailAction.REJECT,
                    )
                )
            else:
                rules.append(
                    GuardrailRule(
                        field_name=term.field_name,
                        max_delta=0.2,
                        action=GuardrailAction.CLIP,
                    )
                )

            covered.add(term.field_name)

        # Ensure all controllable fields are guarded in baseline drafts.
        for field in field_dictionary.fields:
            if not field.controllable or field.field_name in covered:
                continue
            rules.append(
                GuardrailRule(
                    field_name=field.field_name,
                    max_delta=0.2,
                    action=GuardrailAction.CLIP,
                )
            )

        return GuardrailSpec(rules=rules)

    def _estimate_confidence(
        self,
        template: ScenarioTemplate,
        nl_requirements: list[str],
    ) -> float:
        score = 0.55
        if len(template.objective.terms) >= 1:
            score += 0.1
        if len(template.constraints) >= 1:
            score += 0.1
        if len(template.guardrail.rules) >= 1:
            score += 0.1
        if nl_requirements:
            score += 0.1
        if len(template.field_dictionary.fields) >= 6:
            score += 0.05
        return max(0.0, min(0.95, score))

    def _base_risks(self, template: ScenarioTemplate) -> list[MigrationRisk]:
        risks: list[MigrationRisk] = []
        if not template.constraints:
            risks.append(
                MigrationRisk(
                    code="LOW_CONSTRAINT_COVERAGE",
                    message="No constraints detected, optimization safety may be weak.",
                    severity=IssueSeverity.WARN,
                )
            )
        if not template.guardrail.rules:
            risks.append(
                MigrationRisk(
                    code="LOW_GUARDRAIL_COVERAGE",
                    message="No guardrail rules detected for objective fields.",
                    severity=IssueSeverity.WARN,
                )
            )
        return risks

    def _merge_suggestions(
        self,
        template: ScenarioTemplate,
        suggestions: dict[str, Any],
    ) -> ScenarioTemplate:
        if "objective_terms" in suggestions:
            valid_terms: list[ObjectiveTerm] = []
            known_fields = set(template.field_dictionary.field_names())
            for item in suggestions.get("objective_terms", []):
                if item.get("field_name") not in known_fields:
                    continue
                valid_terms.append(ObjectiveTerm.model_validate(item))
            if valid_terms:
                template = template.model_copy(update={"objective": ObjectiveSpec(terms=valid_terms)})

        if "constraints" in suggestions:
            known_fields = set(template.field_dictionary.field_names())
            valid_constraints = []
            for item in suggestions.get("constraints", []):
                if item.get("field_name") not in known_fields:
                    continue
                valid_constraints.append(ConstraintSpec.model_validate(item))
            if valid_constraints:
                template = template.model_copy(update={"constraints": valid_constraints})

        return template
